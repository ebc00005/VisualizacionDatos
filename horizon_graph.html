<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Horizon Graph Multiserie con D3.js</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: system-ui, sans-serif;
      background: #fafafa;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 40px;
    }
    h1 {
      margin-bottom: 30px;
    }
    svg {
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .tooltip {
      position: absolute;
      background: rgba(0,0,0,0.75);
      color: #fff;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 13px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    .label {
      font-size: 14px;
      fill: #333;
      text-anchor: end;
    }
  </style>
</head>
<body>
  <h1>Horizon Graph Multiserie (D3.js)</h1>
  <svg id="chart" width="900" height="500"></svg>
  <div class="tooltip" id="tooltip"></div>

  <script>
    const svg = d3.select("#chart"),
          width = +svg.attr("width"),
          height = +svg.attr("height"),
          nLayers = 4,
          seriesNames = ["Ciudad A", "Ciudad B", "Ciudad C", "Ciudad D"];

    const margin = {top: 20, right: 40, bottom: 40, left: 80};
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;
    const seriesHeight = innerHeight / seriesNames.length;

    const g = svg.append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    // Datos simulados: 4 series con diferentes patrones
    const xValues = d3.range(100);
    const series = seriesNames.map((name, i) => {
      return {
        name,
        values: xValues.map(x => ({
          x,
          y: Math.sin(x / 10 + i) * 20 + Math.random() * 8 - 4
        }))
      };
    });

    // Escalas globales
    const x = d3.scaleLinear()
      .domain(d3.extent(xValues))
      .range([0, innerWidth]);

    const yExtent = d3.extent(series.flatMap(s => s.values.map(v => v.y)));
    const yMax = Math.max(Math.abs(yExtent[0]), Math.abs(yExtent[1]));

    const color = d3.scaleSequential(d3.interpolateRdBu)
      .domain([-yMax, yMax]);

    const area = d3.area()
      .x(d => x(d.x))
      .y0(0)
      .y1(d => d.y);

    // Función que dibuja una serie en estilo horizonte
    function drawHorizon(selection, data) {
      const band = yMax / nLayers;

      for (let i = 0; i < nLayers; i++) {
        const offset = band * i;

        // Positivos
        selection.append("path")
          .datum(data.map(d => ({x: d.x, y: Math.max(0, d.y - offset)})))
          .attr("fill", color(offset))
          .attr("transform", `translate(0,${seriesHeight / 2}) scale(1,-1)`)
          .attr("d", area)
          .attr("opacity", 0)
          .transition().duration(800)
          .attr("opacity", 0.85);

        // Negativos
        selection.append("path")
          .datum(data.map(d => ({x: d.x, y: -Math.max(0, -d.y - offset)})))
          .attr("fill", color(-offset))
          .attr("transform", `translate(0,${seriesHeight / 2})`)
          .attr("d", area)
          .attr("opacity", 0)
          .transition().duration(800)
          .attr("opacity", 0.85);
      }
    }

    // Dibujar todas las series
    series.forEach((s, i) => {
      const group = g.append("g")
        .attr("transform", `translate(0,${i * seriesHeight})`);

      // Etiqueta lateral
      group.append("text")
        .attr("class", "label")
        .attr("x", -10)
        .attr("y", seriesHeight / 2 + 5)
        .text(s.name);

      drawHorizon(group, s.values);
    });

    // Eje X común
    g.append("g")
      .attr("transform", `translate(0,${innerHeight})`)
      .call(d3.axisBottom(x).ticks(10));

    // Tooltip
    const tooltip = d3.select("#tooltip");

    // Puntos invisibles solo para tooltip
    series.forEach((s, i) => {
      g.selectAll(`.dot-${i}`)
        .data(s.values)
        .enter()
        .append("circle")
        .attr("class", `dot-${i}`)
        .attr("cx", d => x(d.x))
        .attr("cy", d => i * seriesHeight + (seriesHeight / 2 - d.y))
        .attr("r", 4)
        .attr("fill", "transparent")
        .on("mouseover", function(event, d) {
          tooltip.style("opacity", 1)
                 .html(`<b>${s.name}</b><br>x: ${d.x}<br>y: ${d.y.toFixed(2)}`)
                 .style("left", (event.pageX + 10) + "px")
                 .style("top", (event.pageY - 20) + "px");
          d3.select(this).attr("fill", "#222");
        })
        .on("mouseout", function() {
          tooltip.style("opacity", 0);
          d3.select(this).attr("fill", "transparent");
        });
    });
  </script>
</body>
</html>
